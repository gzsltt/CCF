/**　　第一天，每个商店都自己定了一个正整数的价格。
店主们希望自己的菜价和其他商店的一致，
第二天，每一家商店都会根据他自己和相邻商店的价格调整自己的价格。
具体的，每家商店都会将第二天的菜价设置为自己和相邻商店第一天菜价的平均值（用去尾法取整）。
　　注意，编号为1的商店只有一个相邻的商店2，编号为n的商店只有一个相邻的商店n-1，其他编号为i的商店有两个相邻的商店i-1和i+1。
　　给定第二天各个商店的菜价，可能存在不同的符合要求的第一天的菜价，请找到符合要求的第一天菜价中字典序最小的一种。
　　字典序大小的定义：对于两个不同的价格序列(a1, a2, ..., an)和(b1, b2, b3, ..., bn)，若存在i (i>=1), 使得ai<bi，且对于所有j<i，aj=bj，则认为第一个序列的字典序小于第二个序列。
输入格式
　　输入的第一行包含一个整数n，表示商店的数量。
　　第二行包含n个正整数，依次表示每个商店第二天的菜价。
输出格式
　　输出一行，包含n个正整数，依次表示每个商店第一天的菜价。
样例输入
8
2 2 1 3 4 9 10 13
样例输出
2 2 2 1 6 5 16 10**/
#include <iostream>

using namespace std;

int main()
{
    /*给定第二天的价格*/
    /*求第一天字典序最小的第一天的价格*/
    /*对于两个不同的价格序列(a1, a2, ..., an)和(b1, b2, b3, ..., bn)，
    若存在i (i>=1), 使得ai<bi，且对于所有j<i，aj=bj，则认为第一个序列的字典序小于第二个序列。*/
    int n;
    int*second=new int[n];
    cin>>n;
    int i,j;
    int a1,a2,a3;
    for(i=0;i<n;i++)
    {
        cin>>second[i];
    }
    int*
    int**first=new int[][n]//价格序列的二维数组
    int num=0;//存在的可能数
    for(i=0;i<n;i++)//列出所有可能
    {
        if(i==0)//第1,2家的可能
        {
            for(a1=0;a1<(second[i]+1)*2;a1++)
            {
                for(a2=)
                a2=(second[i]+1)*2-1-a1;
                first[num][0]=a1;
                first[num][1]=a2;
                num++;
            }
            num-=1;
        }
        else if(i>0&&i<n-1)//第3~n-1家的可能
        {
            for(j=0;j<num;j++)
            {

            }
        }
        else if(i==n-1)
        {

        }
    }
}

